---
layout: post
title: Real MySQL - Chapter 6. 실행계획
category: 'MySQL'
tag: [MySQL, Study]
---

# 6장. 실행 계획

어떤 일을 하기 위해서는 계획이 반드시 필요하다.

마찬가지로, DBMS의 쿼리 실행 또한 실행 계획이 반드시 필요하며, 주로 **옵티마이저**에서 이 기능을 담당한다. 같은 결과를 만들어 낼 때 한 가지 방법만 있는게 아니므로 그중에서 어떤 방법이 최적이고 최소의 비용이 소모될지 결정하는 역할을 한다. 이를 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보를 참조하여 최적의 계획을 세우게 된다.

MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행계획을 확인할 수 있다. 여기에는 많은 정보가 출력되는데, 이번 장에서 자세히 살펴보겠다.

---

## 6.1 개요

어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 이해하기 어려운 부분 중 하나이다. 하지만, 이를 이해해야 더욱 최적화된 방법으로 실행계획을 수립할 수 있어 DBMS를 제대로 사용하기 위해서는 필수적으로 익혀야 하는 부분이다.

먼저, 알고있어야 하는 부분 몇가지를 살펴보자.

### 6.1.1 쿼리 실행 절차

MySQL에서 쿼리가 실행되는 과정은 크게 3가지로 나눌 수 있다.

- **1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.**
    - **SQL Parsing**
    - 실행 주체 : MySQL 서버의 **SQL Parser**
    - 결과물: SQL 파스 트리

    이 단계에서 "SQL 파스 트리"라는 것이 만들어지고, 서버는 이 트리에 의해 쿼리를 처리하게 된다.

    만약 쿼리가 문법적으로 잘못되었다면, 이 단계에서 걸러진다.

- **2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.**
    - **최적화 및 실행계획 수립**
    - 실행 주체: MySQL 서버의 **옵티마이저**
    - 결과물: **실행 계획**

    이 단계에서는 주로 다음과 같은 내용을 처리한다.

    - 불필요한 조건의 제거 및 복잡한 연산의 단순화
    - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
    - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- **3. 위에서 결정된 테이블의 읽기순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.**
    - **결과 생성**
    - 실행 주체: **MySQL 엔진** + **스토리지 엔진** 동시 참여
    - 결과물: 쿼리 결과

    이 단계에서는 실행 계획에 따라 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진은 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

### 6.1.2 옵티마이저의 종류

| 비교     | CBO                                                                                                                                                                 | RBO                                                                                    |
| :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------- |
| 이름     | 비용 기반 최적화<br>Cost-based Optimizer                                                                                                                            | 규칙 기반 최적화<br>Rule-based Optimizer                                               |
| 방법     | 시뮬레이션                                                                                                                                                          | 규칙                                                                                   |
| 상세     | 1. 쿼리를 처리하기 위한 여러가지 방법을 만들고 각 단위 작업의 비용정보와 대상 테이블의 통계 정보를 이용하여 실행계획 별 비용을 산출<br>2. 최소 비용 처리방식을 선택 | 1. 옵티마이저에 내장된 규칙에 따라 실행계획을 수립<br>2. 수립된 실행계획으로 쿼리 실행 |
| 장점     | 통계 정볼를 통한 비용 최소화                                                                                                                                        | 실행 계획이 매우 규칙적이어서 예상 가능                                                |
| 단점     | 실행 계획의 예측 제어 어려움                                                                                                                                        | 통계 정볼르 무시하여 실행 비용 증가할 가능성 높음                                      |
| 인덱스   | Cost에 의한 결정                                                                                                                                                    | 항상 사용                                                                              |
| 사용현황 | 대부분의 상용 DBMS                                                                                                                                                  | Oracle도 10g 버전부터 지원 중단                                                        |

### 6.1.3 통계 정보

MySQL에서 사용중인 CBO(비용 기반 최적화)에서 가장 중요한 것은 통계정보이다.

MySQL은 다른 DBMS와 비교하여 통계정보가 그리 다양하지 않다. 주로 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정도가 전부이다. 하지만, 사용자가 알아채지 못하게 순간순간 자동으로 변경되기 때문에 상당히 동적인 편이다.

하지만, 레코드 건수가 많지 않으면 통계정보가 부정확한 경우가 많으므로 "ANALYZE" 명령을 이용해 강제적으로 통계 정보를 갱신해야 할 때도 있다. (개발용 서버에서 자주 발생)

---

## 6.2 실행 계획 분석

MySQL에서 실행계획을 확인하려면 "EXPLAIN" 명령어를 사용하면 된다. "EXPLAIN EXTENDED"는 더 상세한 실행계획을, "EXPLAIN PARTITIONS"는 해당 파티션에 관한 실행계획을 제공한다.

EXPLAIN 명령어는 EXPLAIN 키워드 뒤에 확인하고 싶은 SELECT 쿼리 문장을 적으면 된다. 실행 결과는 표 형태로 제공되며, 대부분 실행 계획의 순서대로 표시된다(UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수 있다). 쿼리문장에 사용된 테이블(서브쿼리로 임시테이블을 생성한 경우 그 임시테이블까지)의 개수만큼 출력되기 때문에 쿼리당 1줄 이상의 결과로 제공된다.

UPDATE, INSERT, DELETE 쿼리의 경우 실행계획을 확인할 방법은 없으며, WHERE 조건절만 같은 SELECT 문을 실행하여 대략적으로 계획을 확인하는 방법밖에 없다.

- id, select_type, table 칼럼 - 테이블 단위로 실행 순서의 판단 근거 표시
- type 이후의 컬럼 - 각 테이블의 레코드를 어떤 방식으로 읽는지 표시

### 6.2.1 id 칼럼

SELECT 문장은 다시 1개 이상의 하위 SELECT 문장을 포함할 수 있다. 이때, SELECT 키워드 단위로 구분한 것을 "단위 쿼리"라고 표현한다.

```sql
select ...
from (select ... from table_1) tb1,
	table_2 tb_2
where tb1.id = tb2.id;

-- 단위쿼리
select ... from table_1;
select ... from tb1, table_2 tb2 where tb1.id = tb2.id;
```

실행계획에서 가장 왼쪽에 표시되는 id칼럼은 단위 쿼리별로 부여되는 식별자 값이다. 따라서, 쿼리 문장에서 여러개의 테이블을 조인해서 사용했지만 하나의 단위 쿼리로 이루어졌을 경우, 실행계획의 id값은 모두 1로 나타난다. 반대로 각 단위 쿼리가 하나의 테이블만 사용했지만 전체 쿼리가 여러개의 단위 쿼리로 이루어진 경우, id값이 단위 쿼리 단위로 다른 값을 가진다.

### 6.2.2 select_type 칼럼

각 단위 select 쿼리가 어떤 타입인지 표시되는 칼럼이다.

여기에 표시될 수 있는 값은 다음과 같다.

- SIMPLE

    UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우

    쿼리가 아무리 복잡하더라도 select_type이 SIMPLE인 쿼리는 (존재한다면) 반드시 단 하나만 존재하며, 일반적으로 가장 바깥의 SELECT 쿼리이다.

- PRIMARY

    UNION이나 서브쿼리의 가장 바깥쪽에 있는 쿼리인 경우

    SIMPLE과 마찬가지로 select_type이 PRIMARY인 쿼리는 (존재한다면) 반드시 단 하나만 존재하며, 일반적으로 가장 바깥의 SELECT 쿼리이다.

- UNION

    UNION으로 결합하는 단위 쿼리 중 첫번째를 제외한 두번째 이후의 단위 쿼리들의 타입

    첫번째 UNION 쿼리의 select_type이 UNION이 아니라 결합한 전체 집합의 select_type이 표시된다(쿼리에 따라 다르게 표시된다)

    예를 들어,

    ```sql
    explain
    select * from (
    	(select emp_no from employees e1 limit 10)
    	union all
    	(select emp_no from employees e2 limit 10)
    	union all
    	(select emp_no from employees e3 limit 10)
    ) tb;
    ```

    위의 실행결과에서 id가 3, 4인 쿼리는 UNION으로 결합된 쿼리 중 두번째 이상이기 때문에 select_type이 UNION으로 표시된다. id가 2인 첫번째 UNION 쿼리는 세개의 서브 쿼리로 조회한 결과를 결합해 임시 테이블을 만들어서 사용하고 있으므로 DERIVED라는 select_type을 갖는다.

- DEPENDENT UNION

    다른 것은 UNION 타입과 비슷하나, 여기에서 DEPENDENT의 의미는 이 쿼리가 외부의 영향을 받는 것을 의미한다.

    주로 내부 쿼리에서 외부 쿼리에 있는 테이블의 컬럼을 조인에 사용하는 등 쿼리 내부가 아닌 외부를 참조할 때 발생한다.

    보통 서브쿼리가 사용된 경우, 외부보다 내부에 있는 서브쿼리가 먼저 실행되는 것이 일반적이다. 하지만 select_type에 DEPENDENT 키워드가 사용된 실행계획을 갖는 쿼리들은 외부 쿼리에 의존적이므로 내부 쿼리가 외부쿼리보다 먼저 실행될 수 없다. 따라서 이런 경우에는 쿼리가 비효율적인 경우가 많다.

- UNION RESULT

    UNION 결과를 담아두는 테이블을 의미

    MySQL에서 UNION 관련 키워드로 생성된 결과는 임시테이블로 생성되는데, 실행계획 상에서 이 임시 테이블을 가리키는 라인의 select_type이다. 이 타입의 라인은 실제 쿼리에서 단위쿼리가 아니기 때문에 id값은 별도로 부여되지 않는다.

    ```sql
    explain
    select emp_no from salaries where salary > 1000000
    union all
    select emp_no from dept_emp where from_date > '2001-01-01';
    ```

    원래대로라면 아래에 UNION RESULT값이 있어야 하는데, 존재하지 않았다. (책에서는 존재) 버전 차이인가 MySQL 공식 문서를 참고했지만, 여기에도 존재했다. Workbench 특성일 수도 있을 것 같다

    [참고한 MySQL 공식 링크](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type)

- SUBQUERY

    일반적으로 서브쿼리라는 단어를 여러가지를 통틀어서 사용할 때가 많은데, 이곳에서의 SUBQUERY의 의미는 FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.

    - 서브쿼리의 분류
        - 중첩된 쿼리, Nested Query - SELECT 절에 사용된 서브쿼리
        - 서브쿼리, Sub Query - WHERE 절에 사용된 쿼리
        - 파생 테이블, Derived - FROM 절에 사용된 쿼리. RDBMS 전체적으로 인라인 뷰(Inline View), 서브 셀렉트(Sub Select)로 부르기도 한다.

    FROM 절에 사용되는 서브쿼리는 아래에서 살펴볼 DERIVED라는 타입을 가진다.

- DEPENDENT SUBQUERY

    위와 마찬가지로 바깥쪽 쿼리에서 정의된 컬럼을 사용하는 SUBQUERY를 가리킨다.

- DERIVED

    서브쿼리가 FROM 절에 사용된 경우 실행 결과를 메모리나 디스트에 임시테이블로 생성하는 과정을 거치게 되고, 이 테이블을 파생 테이블이라고 한다.

    이 경우 MySQL은 FROM 절에 사용된 쿼리를 제대로 최적하하지 못하는 경우가 많다. 또한 이 테이블들은 인덱스가 없으므로 다른 테이블과 조인할 때 성능상 불리한 경우가 많다.

    쿼리를 튜닝하기 위해서는 실행계획 중에서 가장 먼저 select_type이 DERIVED 인 것을 제거해주어야 한다. 어쩔수 없는 경우도 분명 있지만, 테이블 조인을 통해서 해결할 수 있는 경우라면 변경해주는 습관을 들여야 한다. 

- UNCACHEABLE SUBQUERY

    조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행결과를 그대로 사용할 수 있게 서브 쿼리의 결과를 내부 캐시에 담아둔다.(내부 캐시는 쿼리 캐시나 파생테이블과는 다른 개념이다) 당연하게 이 경우 캐시가 처음 한번만 생성된다. 하지만 캐시 자체가 불가능할 경우가 있는데, 이 경우 select_type이 UNCACHEABLE SUBQUERY로 표시된다.

    아래는 대표적인 경우이다.

    - 사용자 변수가 서브 쿼리에 사용된 경우 (9장 참고)
    - NON-DETERMINISTIC 속성의 스토어드 루틴이 사용된 경우(11장 참고)
    - UUID(), RAND() 등 결과값이 호출할 때마다 달라지는 함수가 사용된 경우
- UNCACHEABLE UNION

    위와 비슷한 경우이며, MySQL 5.1부터 추가된 select_type

### 6.2.3 table 칼럼

실행 계획은 쿼리 기준이 아니라 테이블 기준으로 표시되며, 별칭이 있는 경우 별칭으로 표시된다.

NOW() 함수 등 별도의 테이블이 사용되지 않는 경우 NULL값으로 출력된다.

이 칼럼에 "<>"로 둘러싸인 이름이 명시되는 경우가 있는데, 이 경우는 임시테이블을 의미한다. 또한, 괄호 안에 표시되는 숫자는 단위 쿼리의 id를 지칭한다. 예를 들어, `"<derived2>`"의 값을 갖는 라인은 id가 2이고 select_type이 DERIVED인 임시테이블(DERIVED이기 때문에 파생 테이블이라고 할수도 있다)을 대상으로 하는 실행계획 라인이다.

### 6.2.4 type 컬럼

각 테이블이 어떤 방식으로 레코드를 읽었는지를 의미

표시할 수 있는 값은 아래를 참고하면 된다. 참고로 성능이 빠른 순서대로 나열된 것이며, 맨 하단의 ALL을 제외하고는 모두 인덱스를 사용하는 접근 방법이다.

- system

    InnoDB 테이블에는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방식

    레코드가 1건만 존재하는 또는 존재하지 않는 테이블을 참조하는 방식

    실제로는 거의 보이지 않는다

- const

    테이블의 레코드 건수에 관계없이 PK나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 처리방식

    다중 칼럼으로 이루어져 있을 때, 일부 칼럼만 사용한다면 const 타입의 접근방식을 사용할 수 없으나, 모든 조건을 동등 조건으로 WHERE 절에 명시한다면 const 타입으로 나타난다.

    다른 DMBS에서는 유니크 인덱스 스캔(Unique Index Scan)이라고도 한다.

    타입 이름이 const 인 이유는 옵티마이저가 쿼리를 최적화 할 때 모두 상수화 하기 때문이다. 예를 들어 type이 const인 서브쿼리가 있다면, 그 쿼리는 옵티마이저가 미리 실행하여 상수화 한 후 쿼리를 실행한다.

- eq_ref

    여러 테이블을 조인했을 경우, 처음 읽은 테이블의 키를 다음 테이블의 키에서 검색 조건에 사용할 때 표시됨

    조건

    - 유니크 키의 경우 NOT NULL
    - 다중 칼럼 PK 또는 유니크 키는 모든 칼럼이 비교 조건에 사용되어야 함 → 해당 테이블에 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있음
- ref

    eq_ref와 달리 조인의 순서와 관계없이 사용되며, PK나 유니크 키 등의 제약 조건도 없음

    인덱스 종류와 상관없이 동등(Equal, =) 조건으로 검색할 때 사용됨

    위의 경우보다 빠르진 않지만, 그래도 매우 빠른 레코드 조회 방법 중 하나

    const, eq_ref, ref 모두 WHERE 조건절에 사용되는 비교 연산자가 동등 비교 연산자(=)인 공통점이 있다. 또한, 세가지 방법 모두 매우 빠른 접근 방법이므로 크게 신경쓰지 않고 넘어가도 된다.

- fulltext

    MySQL의 전문 검색(fulltext) 인덱스를 사용해 레코드를 읽는 접근 방법

    "MATCH ... AGAINST..." 구문을 사용해서 실행하고, 반드시 해당 테이블에 전문 검색용 인덱스가 준비되어 있어야 한다

    전문 검색 인덱스는 통계 정보가 관리되지 않기 때문에 MySQL 옵티마이저는 다른 방식보다 이 방식을 사용하는 경우가 대부분이다. (const/eq_ref/ref가 아닌 이상)

    경험상 다른 방식이 더 빨리 처리되는 경우가 많았기 때문에, 전문 검색 쿼리를 사용할 때는 각 조건별 성능을 확인해 적절한 방식을 택하는 것이 좋다

- ref_or_null

    ref + "IS NULL"

    거의 보이지 않아 대략의 의미만 기억해두어도 충분하다

- unique_subquery

    IN (subquery)에서 중복되지 않은 유니크한 값만 반환할 때 사용

    ```sql
    explain
    select * from departments where dept_no in (
    	select dept_no from dept_emp where emp_no = 10001);
    ```

    위의 경우, 서브 쿼리에서 부서 번호는 중복이 없기 때문에(dept_emp에서 dept_no, emp_no가 PK이기 때문에) 서브쿼리의 접근 방식은 unique_subquery로 표시됨

- index_subquery

    IN (subquery)에서 중복된 값을 반환할 수 있지만, 인덱스를 이용해 제거할 수 있을 때 사용

- range

    인덱스를 하나의 값이 아니라 범위로 검색하는 경우

    <, >, IS NULL, BETWEEN, IN, LIKE 등을 사용

    그렇게 느리지 않으며 어느정도 성능이 보장된다

    보통 "인덱스 레인지 스캔" 또는 "레인지 스캔"이라고 하면, const/ref/range 를 묶어서 지칭하는 경우가 많다

- index_merge

    2개 이상의 인덱스를 이용해 검색 결과를 만들고 그 결과를 병합하는 방식

    공식 메뉴얼에는 ref_or_null 다음에 있지만, 경험상 성능이 좋지 못하기 때문에 range 밑으로 옮김

    특징

    - 여러 인덱스를 읽어야 하므로 효율성이 떨어짐
    - AND, OR 연산이 복잡한 경우 제대로 최적화 하지 못하는 경우가 많음
    - 전문 검색 인덱스에는 적용되지 않음
    - 2개 이상의 집합을 병합하기 때문에, 교집합/합집합/중복 제거 등의 부가작업이 필요함
- index

    인덱스 풀 스캔

    index라는 단어 때문에 효율적인 방식일 것 같으나, 풀 스캔이기 때문에 그렇지 않음

    다음 조건 중 첫번째는 무조건 해당하고, 두번째/세번째 조건 중 하나를 만족하는 경우

    - range, const, ref로 처리할 수 없을 경우
    - 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리일 경우
    - 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우
- ALL

    풀 테이블 스캔

    테이블을 처음부터 끝까지 읽어 불필요한 레코드를 제거하는 방식이기 때문에 가장 비효율적

    다른 DBMS와 같이 InnoDB도 한꺼번에 많은 페이지를 읽어들이는 기능을 제공하긴 함

    잘못 튜닝된 것보다는 나을 수도 있다

### 6.2.5 possible_keys

**사용될 법했던 인덱스의 목록**

쿼리를 튜닝하는데 아무런 도움이 되지 않으므로 무시하자

### 6.2.6 key

**최종 선택된 실행 계획에서 사용된 인덱스**

의도했던 인덱스가 표시되는지 확인하는 것이 중요함

PK가 사용된 경우, 값이 "PRIMARY"로 표시됨

실행 타입이 index_merge인 경우, 여러개의 인덱스를 이용하기 때문에 복수의 인덱스가 표시됨

### 6.2.7 key_len

쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 바이트까지 사용했는지 표시

실제 업무에서는 다중 칼럼 인덱스가 훨씬 많기 때문에 매우 중요한 정보 중 하나

대부분 모든 칼럼을 사용하는 것이 훨씬 성능이 좋다

### 6.2.8 ref

접근 방법이 ref일 경우, 어떤 값이 제공되었는지 표시

func라고 표시된 경우, 값의 가공이 포함되었기 때문에 주의깊게 봐야 한다

- MySQL 내부적으로 값을 변환해야 할 때도 func로 표시된다
- 대표적으로 조인할 때 조인하는 컬럼의 타입이 다르면 변환을 거치기 때문에 func로 표시
- 되도록 조인 칼럼의 타입을 일치시키는 편이 좋다

### 6.2.9 rows

실행 계획의 효율성 판단을 위해 옵티마이저가 읽어야 할 것이라고 판단한 값

실제 읽은 row의 갯수가 아니라 예측값이라 LIMIT 조건을 추가하면 정확하지 않은 경우가 많다

실제 쿼리 실행 결과의 row 갯수가 아니다

조건에 따라 rows 값이 달라지고, 그에 따라 옵티마이저가 결정하는 스캔 방식이 달라진다

### 6.2.10 Extra

컬럼 이름과는 달리, 쿼리 실행 계획에서 성능과 관련된 중요한 내용이 표시됨

나중에 필요할 때 인터넷에서 찾아볼 것

---

## 6.3 MySQL의 주요 처리 방식

성능에 미치는 영향이 큰 실행계획과 연관이 있는 단위 작업에 대해 조금 더 살펴보자

### 6.3.1 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리하는 작업

**풀 테이블 스캔 조건**

- 테이블의 레코드 건수가 너무 작아서 풀 테이블 스캔이 더 빠른 경우
- WHERE절이나 ON절에 인덱스를 사용할 수 있는 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 순 있지만, 일치 레코드 조건이 너무 많아 소용이 없는 경우 (인덱스 B-tree를 샘플링해서 조사한 통계 정보 기준)
- 설정에서 max_seeks_for_key 변수를 특정 값으로 설정하면 최대 N건만 읽으면 된다고 판단하여 풀 테이블 스캔이 유리하다고 판단되는 경우

대부분의 DBMS는 풀 테이블 스캔을 할 때 여러개의 페이지를 한꺼번에 읽는게 일반적

MySQL은 해당 변수가 존재하지 않아 페이지를 하나씩 읽어오는 것으로 오해하지만 사실이 아니다

InnoDB 스토리지 엔진은 (MyISAM 방식은 하나씩 읽어오는게 맞음) 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read Ahead) 작업이 자동으로 실행됨

처음 몇개의 페이지는 포어그라운드(Foreground) 스레드에 의해 페이지가 읽히지만, 특정 시점부터는 한번에 여러개의 페이지(처음에는 4 or 8개로 시작해 최대 64개의 페이지까지 증가)를 읽어서 버퍼 풀에 저장해 둠

### 6.3.2 ORDER BY 처리 (Using filesort)

정렬을 처리하는 방법은 

1. 인덱스를 사용하는 방법

    **장점**  
    → 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되므로 편하다
    
    **단점**  
    → INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림  
    → 인덱스 저장 공간으로 추가적인 디스크 공간이 필요함  
    → 인덱스 갯수가 늘어날수록 메모리가 많이 필요함  
2. Filesort라는 별도의 처리를 이용하는 방법
   
    **장점**  
    → 인덱스를 생성하지 않아도 됨 (인덱스의 단점이 장점으로)  
    → 정렬해야 하는 레코드가 많지 않으면 충분히 빠르다  
    
    **단점**  
    → 레코드 대상 건수가 많아질수록 느림  

아래는 정렬이 처리되는 방식이며, 이를 이해한다면 쿼리 튜닝할 때 도움이 될 것이다

**소트 버퍼(Sort Buffer)**

- 정렬을 위한 별도의 메모리 공간
- 시스템 변수로 설정 가능(sort_buffer_size)
- 정렬해야 할 데이터가 소트 버퍼보다 크다면?
    - 레코드를 여러 조각으로 나누어서 처리하는데, 임시저장을 위해 디스크를 사용함
    - 임시 저장한 레코드의 부분을 병합하는 과정을 멀티 머지(Multi-merge)라고 하고, Sort_merge_passes라는 변수에 저장됨
- 소트 버퍼의 크기는 1MB 미만이 적절한 것으로 생각됨 (무조건 크다고 좋은 것은 아님, 일정 이상 커진다면 성능의 차이가 없음)
- 또한, 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니기 때문에 커넥션이 많을수록 버퍼 메모리 공간이 커짐 → 메모리 부족으로 MySQL 서버가 죽을 수 있음

**정렬 알고리즘**

- 싱글 패스(Single Pass) 알고리즘
    - SELECT에 포함된 모든 컬럼(정렬에 필요하지 않은 컬럼도 포함)하여 정렬을 수행하는 방법
    - MySQL 5.0 이상부터 지원
- 투 패스(Two Pass) 알고리즘
    - 정렬 대상 컬럼과 PK만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK를 이용하여 테이블을 읽어 SELECT 할 컬럼을 가져오는 알고리즘
    - 예전 버전의 MySQL에서 사용하던 방법
        - 특정 조건이 되면 최신 버전의 MySQL도 이 방법을 사용

최근의 MySQL은 일반적으로 싱글 패스 알고리즘을 사용하나 다음과 같은 경우 그렇지 않다

- 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

성능

- 싱글패스 알고리즘은 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 반대의 경우 투패스 알고리즘이 더 좋은 효율을 보일 때도 있다

SELECT 쿼리에서 모든 칼럼(*)을 가져오는 경우, 정렬 버퍼 또는 임시테이블을 생성 할 때 몇배에서 몇십배까지 비효율적으로 사용할 가능성이 크다. 따라서, 꼭 필요한 칼럼만 조회하도록 쿼리를 작성하는 것이 좋다고 권장된다.

**정렬의 처리방식**

쿼리에 ORDER BY가 사용되면 다음 3가지 처리방식 중 하나로 처리된다. (순서는 속도)

1. 인덱스 사용한 정렬
    - 실행계획의 Extra에서 별도로 내용 표기 없음
    - 조건
        - ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 함
        - WHERE 절에 첫 번째 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
        - B-Tree 계열의 인덱스가 아닌 인덱스는 사용할 수 없다 (예외적으로 R-Tree도 사용 불가)
        - 여러 테이블이 조인되는 경우 네스티드 루프(Nested Loop) 방식의 조인에서만 사용 가능
    - 실제 인덱스 값이 정렬되어 있기 때문에 정렬을 위한 별도의 작업이 수행되지 않음

    인덱스를 이용한 정렬은 추가 작업이 없기 때문에 일부러 ORDER BY 문을 뺄 필요는 없다. 또한, 쿼리의 실행 계획이 변경될 수 있기 때문에 ORDER BY를 제외한 쿼리는 실행 결과가 달라질 수 있어 어플리케이션의 버그로 연결될 수도 있다.

2. 드라이블 테이블만 정렬 (조인이 없는 경우도 포함)
    - 실행계획의 Extra에서 "Using filesort"
    - 조건
        - 조인에서 첫 번째 읽히는 테이블의 칼럼만으로 ORDER BY 절이 작성되어야 함
    - 옵티마이저가 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과에 다른 테이블을 조인하기 때문에 정렬 대상 레코드가 적음
3. 조인 결과를 임시테이블로 저장 후, 임시테이블에서 정렬
    - 실행계획의 Extra에서 "Using temporary; Using filesort"가 같이 표시
    - 조인의 결과를 임시테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거치기 때문에 일반적으로 가장 느림

**정렬 방식의 성능 비교**

쿼리의 처리 방식을 두 가지로 나누어서 생각해보자

1. 스트리밍 방식

    : 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식

    : 웹 서비스 같은 OLTP 환경에서는 요청부터 첫 번째 레코드를 전달받게 되는 응답시간이 중요하기 때문에 빠른 응답시간을 보장할 수 있다

    : LIMIT과 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행시간을 상당히 줄여줄 수 있다

2. 버퍼링 방식

    : 결과를 모아서 MySQL 서버에서 일괄 가공한 후 데이터를 제공하는 쿼리 처리 방식

    : ORDER BY나 GROUP BY의 경우, WHERE 조건에 일치하는 모든 레코드를 가져온 후, 일련의 처리를 거쳐 차례대로 보내야 하기 때문에 버퍼링 방식에 해당된다

위의 **정렬의 처리 방식**에서 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 버퍼링 방식에 해당된다.

따라서 가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것이 좋은 튜닝 방향이라 할 수 있다.

그렇다고 LIMIT 조건이 아무런 도움이 되지 못하는 것은 아니다. MySQL 서버는 정해진 갯수가 채워진다면 정렬을 멈추고 결과를 반환한다. 하지만, MySQL 서버는 퀵소트 알고리즘을 사용하므로, 정해진 갯수보다 많은 정렬 작업이 필요할 수 있다.

### 6.3.3 GROUP BY 처리

GROUP BY 작업 방식은 다음 세 가지로 나뉜다.

1. 타이트(Tight) 인덱스 스캔을 이용한 GROUP BY 처리

    : GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 작업 수행

    : 그룹 함수 등의 영향으로 임시 테이블이 필요할 때도 있다

2. 루스(Loose) 인덱스 스캔을 이용한 GROUP BY 처리

    : 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미

    : 멀티 인덱스의 순서를 만족하는 GROUP BY 칼럼이면 가능하다

    ex) 인덱스 - col1, col2, col3 일 때, GROUP BY col1, col2

    : 이미 존재하는 인덱스를 차례대로 스캔하면서 GROUP BY 칼럼의 유니크한 값을 찾은 다음, 그 조건을 추가하여 계속 검색하여 원하는 데이터를 만들어 내는 방식

    : 유니크한 값이 수가 적을수록(분포도가 좋지 않은 인덱스일수록) 더 빠른 결과를 만들어낸다

    다른 DBMS의 경우 인덱스의 첫 번째 칼럼에 대한 조건을 마음대로 만들어서 추가하는 기능이 구현되어 있다. 이 책 기준(MySQL 5.5) MySQL은 이 기능을 지원하지 않는다.

3. 임시테이블을 이용한 GROUP BY 처리

    : 가장 느린 방식이며, 위의 방식을 사용할 수 없을 경우 사용된다.

### 6.3.4 DISTINCT 처리

특정 칼럼의 유니크한 값 만을 조회하는 기능

**단독으로 사용될 경우**

이 경우에는 GROUP BY와 거의 같은 방식으로 처리된다

인덱스를 사용하는 DISTINCT는 GROUP BY와 완전히 같은 방식으로 처리되지만, 인덱스를 사용하지 못하는 DISTINCT 작업은 순서를 보장하지 않는다는 점이 차이점이다

- 참고

    DISTINCT는 SELECT하는 레코드(튜플)을 유니크하게 SELECT하는 것

    DISTINCT를 여러 컬럼에 할 경우, 그 컬럼들의 값의 조합이 유니크하게 나타난다

    일부 컬럼에 괄호를 포함해도 MySQL 서버가 제거함

**집합 함수와 함께 사용된 DISTINCT**

이 경우 위와 다른 형태로 해석된다

집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져온다

이 방식도 비슷하게 인덱스를 이용할 수 있다면 임시 테이블을 생성 하지 않지만, 그 외의 경우 임시 테이블을 이용한다(하지만, 실행 계획에 "Using temporary"가 표시되지 않기 때문에 주의가 필요하다)

DISTINCT가 집합 함수 밖에서/안에서 사용될 경우 쿼리의 결과 값이 조금씩 달라진다. 아래 쿼리의 차이를 잘 이해해야 한다.
1. SELECT DISTINCT first_name, last_name
2. SELECT COUNT(DISTINCT first_name), COUNT(DISTINCT last_name)
3. SELECT COUNT(DISTINCT first_name, last_name)

### 6.3.5 임시 테이블(Using temporary)

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑 할 때 내부적으로 사용하는 테이블

"CREATE TEMPORARY TABLE"과는 다름

- 처음에는 메모리에 생성되었다가 테이블의 크기가 커지면 디스크로 옮겨감
- 다른 세션이나 다른 쿼리에서는 볼 수 없으며, 사용도 불가하다
- 쿼리의 처리가 완료되면 자동으로 삭제된다

**임시 테이블이 필요한 쿼리**

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 컬럼이 UNION RESULT인 경우)
- UNION ALL이 사용된 쿼리(select_type 컬럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

: 실행계획에서 Extra 컬럼에 "Using temporary"라는 키워드가 표시되면 임시테이블이 사용되는 것이다 (단, 위 케이스에서 마지막 3개 패턴은 키워드가 표시되지 않는다.)

: 보통 유니크 인덱스가 있는 내부 임시 테이블이 만들어지며, 위 마지막 2개 케이스는 유니크 인덱스가 없는 임시테이블이 생성됨 (유니크 인덱스가 존재하면 처리성능이 상당히 느리다)

**임시 테이블이 디스크에 생성되는 경우**

: MyISAM 스토리지 엔진을 사용

: 다음과 같은 경우 임시 테이블이 디스크에 생성된다

- 저장해야 하는 내용 중 BLOB이나 TEXT등 대용량 칼럼이 있는 경우
- 레코드 전체 크기나 UNION/UNION ALL에서 SELECT되는 칼럼 중에 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상의 크기의 칼럼이 있는 경우
- 임시 테이블에 저장할 데이터의 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정 값보다 큰 경우

    → 이 경우 처음에는 MEMORY 스토리지 엔진을 이용하여 생성되지만, 테이블의 크기가 시스템 설정 값을 넘어서는 순간 디스크의 MyISAM 테이블로 변환됨

**임시 테이블 관련 상태 변수**

MySQL 서버의 상태변수를 통해 몇번 임시테이블이 어디에 만들어졌는지 확인 가능

```sql
SHOW SESSION STATUS LIKE 'Created_tmp%';
-- Created_tmp_disk_tables/Created_tmp_tables 확인 가능
```

**임시 테이블 관련 주의사항**

임시 테이블이 메모리에 생성되면 크게 영향을 미치지 않는다. 하지만, 디스크에 생성되면 성능상의 이슈를 발생시킬 수도 있다.

- 가능한 인덱스를 이용하여 처리하는 쿼리를 만들고, 처음부터 임시 테이블이 필요하지 않게 하는 것이 좋다
- 메모리를 활용한 임시 테이블을 사용할 수 있도록 가공 대상 레코드를 적게 만드는 것이 좋다
- tmp_table_size 또는 max_heap_table_size를 무조건 크게 설정하면 메모리를 내부 임시 테이블이 사용할 수 있으므로 주의해아 한다
- 임시 테이블의 모든 칼럼은 고정 크기 칼럼임을 주의해야 한다. ex) VARCHAR(512)의 칼럼은 한 글자를 저장 하더라도 많은 크기를 사용한다.

### 6.3.6 테이블 조인

> To Be Added